/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package ivk.skill.api.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import ivk.skill.api.models.ConfigurationResponse
import ivk.skill.api.models.MatchResultRequest
import ivk.skill.api.models.MatchResultResponse
import ivk.skill.api.models.PreMatchRequest
import ivk.skill.api.models.PreMatchResponse

import com.squareup.moshi.Json

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import ivk.skill.api.infrastructure.ApiClient
import ivk.skill.api.infrastructure.ApiResponse
import ivk.skill.api.infrastructure.ClientException
import ivk.skill.api.infrastructure.ClientError
import ivk.skill.api.infrastructure.ServerException
import ivk.skill.api.infrastructure.ServerError
import ivk.skill.api.infrastructure.MultiValueMap
import ivk.skill.api.infrastructure.PartConfig
import ivk.skill.api.infrastructure.RequestConfig
import ivk.skill.api.infrastructure.RequestMethod
import ivk.skill.api.infrastructure.ResponseType
import ivk.skill.api.infrastructure.Success
import ivk.skill.api.infrastructure.toMultiValue

class SkillApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://skill.ivk.dev")
        }
    }

    /**
     * GET /api/v2/{model_id}/configuration
     * 
     *  Get the current model configuration
     * @param modelId ID of the skill rating model
     * @return ConfigurationResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getConfiguration(modelId: kotlin.String) : ConfigurationResponse = withContext(Dispatchers.IO) {
        val localVarResponse = getConfigurationWithHttpInfo(modelId = modelId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConfigurationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/v2/{model_id}/configuration
     * 
     *  Get the current model configuration
     * @param modelId ID of the skill rating model
     * @return ApiResponse<ConfigurationResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getConfigurationWithHttpInfo(modelId: kotlin.String) : ApiResponse<ConfigurationResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getConfigurationRequestConfig(modelId = modelId)

        return@withContext request<Unit, ConfigurationResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getConfiguration
     *
     * @param modelId ID of the skill rating model
     * @return RequestConfig
     */
    fun getConfigurationRequestConfig(modelId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/{model_id}/configuration".replace("{"+"model_id"+"}", encodeURIComponent(modelId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/{model_id}/match_result/{environment}
     * 
     * During or after the match, you can retrieve skill rating updates based on the provided player sessions.
     * @param modelId ID of the skill rating model
     * @param environment Environment
     * @param matchResultRequest 
     * @return MatchResultResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun postMatchResult(modelId: kotlin.String, environment: kotlin.String, matchResultRequest: MatchResultRequest) : MatchResultResponse = withContext(Dispatchers.IO) {
        val localVarResponse = postMatchResultWithHttpInfo(modelId = modelId, environment = environment, matchResultRequest = matchResultRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MatchResultResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/{model_id}/match_result/{environment}
     * 
     * During or after the match, you can retrieve skill rating updates based on the provided player sessions.
     * @param modelId ID of the skill rating model
     * @param environment Environment
     * @param matchResultRequest 
     * @return ApiResponse<MatchResultResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun postMatchResultWithHttpInfo(modelId: kotlin.String, environment: kotlin.String, matchResultRequest: MatchResultRequest) : ApiResponse<MatchResultResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = postMatchResultRequestConfig(modelId = modelId, environment = environment, matchResultRequest = matchResultRequest)

        return@withContext request<MatchResultRequest, MatchResultResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postMatchResult
     *
     * @param modelId ID of the skill rating model
     * @param environment Environment
     * @param matchResultRequest 
     * @return RequestConfig
     */
    fun postMatchResultRequestConfig(modelId: kotlin.String, environment: kotlin.String, matchResultRequest: MatchResultRequest) : RequestConfig<MatchResultRequest> {
        val localVariableBody = matchResultRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/{model_id}/match_result/{environment}".replace("{"+"model_id"+"}", encodeURIComponent(modelId.toString())).replace("{"+"environment"+"}", encodeURIComponent(environment.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/v2/{model_id}/pre_match/{environment}
     * 
     * Useful to calculate the expected outcome.
     * @param modelId ID of the skill rating model
     * @param environment Environment
     * @param preMatchRequest 
     * @return PreMatchResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun postPreMatch(modelId: kotlin.String, environment: kotlin.String, preMatchRequest: PreMatchRequest) : PreMatchResponse = withContext(Dispatchers.IO) {
        val localVarResponse = postPreMatchWithHttpInfo(modelId = modelId, environment = environment, preMatchRequest = preMatchRequest)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PreMatchResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/v2/{model_id}/pre_match/{environment}
     * 
     * Useful to calculate the expected outcome.
     * @param modelId ID of the skill rating model
     * @param environment Environment
     * @param preMatchRequest 
     * @return ApiResponse<PreMatchResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun postPreMatchWithHttpInfo(modelId: kotlin.String, environment: kotlin.String, preMatchRequest: PreMatchRequest) : ApiResponse<PreMatchResponse?> = withContext(Dispatchers.IO) {
        val localVariableConfig = postPreMatchRequestConfig(modelId = modelId, environment = environment, preMatchRequest = preMatchRequest)

        return@withContext request<PreMatchRequest, PreMatchResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postPreMatch
     *
     * @param modelId ID of the skill rating model
     * @param environment Environment
     * @param preMatchRequest 
     * @return RequestConfig
     */
    fun postPreMatchRequestConfig(modelId: kotlin.String, environment: kotlin.String, preMatchRequest: PreMatchRequest) : RequestConfig<PreMatchRequest> {
        val localVariableBody = preMatchRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/{model_id}/pre_match/{environment}".replace("{"+"model_id"+"}", encodeURIComponent(modelId.toString())).replace("{"+"environment"+"}", encodeURIComponent(environment.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
